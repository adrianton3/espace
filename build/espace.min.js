/* Copyright 2017 Adrian Toncean; released under the MIT license */
((espace) => {
(function(){"use strict";const Expander={};function extract(source,pattern){const map={};function extract(source,pattern){if(pattern.type==="list"){if(source.type!=="list"||source.token.value!==pattern.token.value){return false}if(pattern.rest){if(source.children.length<pattern.rest.before+1+pattern.rest.after){return false}}else{if(source.children.length!==pattern.children.length){return false}}if(source.children[0].token.type!=="identifier"||source.children[0].token.value!==pattern.children[0].token.value){return false}if(pattern.rest){for(let i=1;i<=pattern.rest.before;i++){if(!extract(source.children[i],pattern.children[i])){return false}}map[pattern.rest.name]=source.children.slice(1+pattern.rest.before,source.children.length-pattern.rest.after);for(let i=0;i<pattern.rest.after;i++){if(!extract(source.children[source.children.length-pattern.rest.after+i],pattern.children[i+1+1+pattern.rest.before])){return false}}}else{for(let i=1;i<pattern.children.length;i++){if(!extract(source.children[i],pattern.children[i])){return false}}}return true}else{map[pattern.token.value]=source;return true}}if(extract(source,pattern)){return map}else{return null}}Expander.extract=extract;function deepClone(tree){const treeClone={type:tree.type,token:{type:tree.token.type,value:tree.token.value}};if(tree.type==="list"){treeClone.children=tree.children.map(function(subtree){return deepClone(subtree)})}return treeClone}Expander.deepClone=deepClone;function insert(array,start,subArray){const args=[start,1].concat(subArray);Array.prototype.splice.apply(array,args);return array}function isPrefixed(string){return string.length>1&&string[0]==="_"}function inject(tree,map,suffixes){const suffixesThisRound={};function inject(tree){if(tree.children.length){const child=tree.children[0];if(isPrefixed(child.token.value)){if(!suffixesThisRound[child.token.value]){if(typeof suffixes[child.token.value]!=="undefined"){suffixes[child.token.value]++}else{suffixes[child.token.value]=0}suffixesThisRound[child.token.value]=child.token.value+"_"+suffixes[child.token.value]}child.token.value=suffixesThisRound[child.token.value]}}for(let i=1;i<tree.children.length;i++){const child=tree.children[i];if(child.token.type==="identifier"){const replaceTree=map[child.token.value];if(Array.isArray(replaceTree)){insert(tree.children,i,replaceTree);i+=replaceTree.length-1}else if(replaceTree){tree.children[i]=replaceTree}else if(isPrefixed(child.token.value)){if(!suffixesThisRound[child.token.value]){if(typeof suffixes[child.token.value]!=="undefined"){suffixes[child.token.value]++}else{suffixes[child.token.value]=0}suffixesThisRound[child.token.value]=child.token.value+"_"+suffixes[child.token.value]}child.token.value=suffixesThisRound[child.token.value]}}else if(child.type==="list"){inject(child)}}}if(tree.token.type==="identifier"){const replaceTree=map[tree.token.value];if(replaceTree){tree.token=replaceTree.token;if(replaceTree.type==="list"){tree.children=replaceTree.children}}}else if(tree.type==="list"){inject(tree)}}Expander.inject=inject;function isRest(string){return string.length>3&&string.substr(string.length-3)==="..."}function processForRest(tree){function traverse(tree){if(tree.type==="list"){for(let i=1;i<tree.children.length;i++){const token=tree.children[i].token;if(token.type==="identifier"&&isRest(token.value)){tree.rest={before:i-1,after:tree.children.length-i-1,name:token.value}}else{traverse(tree.children[i])}}}}traverse(tree);return tree}Expander.processForRest=processForRest;function validatePattern(tree){const set={};function traverse(tree){if(tree.children.length>0&&tree.children[0].token.type!=="identifier"){throw new Error("Tokens of type "+tree.children[0].token.type+" are not allowed in patterns")}let rest=false;for(let i=1;i<tree.children.length;i++){const subTree=tree.children[i];if(subTree.token.type==="identifier"){if(isPrefixed(subTree.token.value)){throw new Error("Pattern can not contain variables prefixed by '_'")}if(set[subTree.token.value]){throw new Error('Variable "'+subTree.token.value+'" already used in pattern')}else{set[subTree.token.value]=true}if(isRest(subTree.token.value)){if(rest){throw new Error("Pattern can contain at most one rest variable on a level")}rest=true}}else if(subTree.type==="list"){traverse(subTree)}else{throw new Error("Tokens of type "+subTree.token.type+" are not allowed in patterns")}}}if(tree.type==="list"){traverse(tree)}else{throw new Error("Pattern must not be an atom")}}Expander.validatePattern=validatePattern;Expander.expand=function(source,pattern,substitute,suffixes){processForRest(pattern);suffixes=suffixes||{};function traverse(source){const map=extract(source,pattern);if(map){const newSubtree=deepClone(substitute);inject(newSubtree,map,suffixes);source.token=newSubtree.token;source.children=newSubtree.children}if(source.type==="list"){source.children.forEach(traverse)}}traverse(source)};espace.Expander=Expander})();(function(){"use strict";const Parser={};function raise(token,message){const ex=new Error(message);ex.coords=token.coords;throw ex}function makeList(token){if(token.type==="open"){return{type:"list",token:token,children:[]}}return{type:"list",token:token,children:[{type:"atom",token:{type:"identifier",value:token.value}}]}}function isMatching(open,closed){return open==="("&&closed===")"||open==="["&&closed==="]"||open==="{"&&closed==="}"}Parser.parse=function(tokens){if(!tokens.length){return null}let root;const stack=[];let currentLevel=null;let token=tokens[0];if(token.type==="open"||token.type==="prefix"){currentLevel=makeList(token);root=currentLevel;stack.push(currentLevel)}else if(token.type==="closed"){raise(token,"Cannot start with )")}else{if(tokens.length>1){raise(token,"Unexpected token")}return{type:"atom",token:token}}for(let i=1;i<tokens.length;i++){token=tokens[i];if(!currentLevel){raise(token,"Unexpected token")}if(token.type==="open"||token.type==="prefix"){const newLevel=makeList(token);currentLevel.children.push(newLevel);currentLevel=newLevel;stack.push(currentLevel)}else{if(token.type==="closed"){const lastLevel=stack.pop();if(!isMatching(lastLevel.token.value,token.value)){raise(token,"Paren types must match")}currentLevel=stack[stack.length-1]}else{currentLevel.children.push({type:"atom",token:token})}while(currentLevel&&currentLevel.token.type==="prefix"){stack.pop();currentLevel=stack[stack.length-1]}}}if(stack.length){raise(token,"Missing )")}return root};espace.Parser=Parser})();(function(){"use strict";function serialize(expression){if(!expression){return""}if(expression.type==="list"){if(expression.token.type==="prefix"){return expression.token.value+serialize(expression.children[0])}else{const childrenString=expression.children.map(serialize).join(" ");return expression.token.value==="("?`(${childrenString})`:expression.token.value==="["?`[${childrenString}]`:`{${childrenString}}`}}switch(expression.token.type){case"string":return'"'+expression.token.value+'"';case"number":return""+expression.token.value;case"identifier":return expression.token.value}}espace.Serializer={serialize:serialize}})();(function(){"use strict";function IterableString(string){this.string=string;this.pointer=0;this.marker=0;this.line=1;this.column=1}IterableString.prototype.advance=function(){if(this.current()==="\n"){this.line++;this.column=1}else{this.column++}this.pointer++};IterableString.prototype.setMarker=function(offset){offset=offset||0;this.marker=this.pointer+offset};IterableString.prototype.current=function(){return this.string.charAt(this.pointer)};IterableString.prototype.next=function(){return this.string.charAt(this.pointer+1)};IterableString.prototype.hasNext=function(){return this.pointer<this.string.length};IterableString.prototype.getMarked=function(offset){offset=offset||0;return this.string.substring(this.marker,this.pointer+offset)};IterableString.prototype.getCoords=function(){return{line:this.line,column:this.column}};espace.IterableString=IterableString})();(function(){"use strict";function raise(coords,message){const ex=new Error(message);ex.coords=coords;throw ex}function Tokenizer(options){options=options||{};const ws=!!options.whitespace;const comments=!!options.comments;const coords=!!options.coords;const prefixes=options.prefixes||{};const makeToken=coords?(type,value,coords)=>({type:type,value:value,coords:coords}):(type,value)=>({type:type,value:value});const escape={"\\":"\\",n:"\n",t:"\t","'":"'",'"':'"'};function stringSingle(str){const accumulated=[];str.advance();while(true){if(str.current()==="\\"){str.advance();if(escape[str.current()]){accumulated.push(escape[str.current()])}}else if(str.current()==="'"){str.advance();return makeToken("string",accumulated.join(""),str.getCoords())}else if(str.current()==="\n"||!str.hasNext()){raise(str.getCoords(),"String not properly ended")}else{accumulated.push(str.current())}str.advance()}}function stringDouble(str){const accumulated=[];str.advance();while(true){if(str.current()==="\\"){str.advance();if(escape[str.current()]){accumulated.push(escape[str.current()])}}else if(str.current()==='"'){str.advance();return makeToken("string",accumulated.join(""),str.getCoords())}else if(str.current()==="\n"||!str.hasNext()){raise(str.getCoords(),"String not properly ended")}else{accumulated.push(str.current())}str.advance()}}function number(str){str.setMarker();let tmp=str.current();while(tmp>="0"&&tmp<="9"){str.advance();tmp=str.current()}if(str.current()==="."){str.advance();let tmp=str.current();while(tmp>="0"&&tmp<="9"){str.advance();tmp=str.current()}}if(!")]} \n\t".includes(str.current())){raise(str.getCoords(),"Unexpected character '"+str.current()+"' after '"+str.getMarked()+"'")}return makeToken("number",+str.getMarked(),str.getCoords())}function commentMulti(str){str.setMarker(2);str.advance();str.advance();while(true){if(str.current()==="-"&&str.next()===";"){str.advance();str.advance();return makeToken("comment",str.getMarked(-2),str.getCoords())}else if(str.hasNext()){str.advance()}else{raise(str.getCoords(),"Multiline comment not properly terminated")}}}function commentSingle(str){str.setMarker(1);str.advance();while(true){if(str.current()==="\n"||!str.hasNext()){str.advance();return makeToken("comment",str.getMarked(),str.getCoords())}else{str.advance()}}}function identifier(str){str.setMarker();let tmp=str.current();while(tmp>" "&&tmp<="~"&&tmp!=="("&&tmp!==")"&&tmp!=="["&&tmp!=="]"&&tmp!=="{"&&tmp!=="}"){str.advance();tmp=str.current()}return makeToken("identifier",str.getMarked(),str.getCoords())}function whitespace(str){const tmp=str.current();str.advance();return makeToken("whitespace",tmp,str.getCoords())}return function chop(string){const str=new espace.IterableString(string);const tokens=[];while(str.hasNext()){const current=str.current();if(current==="'"){tokens.push(stringSingle(str))}else if(current==='"'){tokens.push(stringDouble(str))}else if(current===";"){const next=str.next();if(next==="-"){const tmp=commentMulti(str);if(comments){tokens.push(tmp)}}else{const tmp=commentSingle(str);if(comments){tokens.push(tmp)}}}else if(current>="0"&&current<="9"){tokens.push(number(str))}else if(current==="("||current==="["||current==="{"){tokens.push(makeToken("open",current,str.getCoords()));str.advance()}else if(current===")"||current==="]"||current==="}"){tokens.push(makeToken("closed",current,str.getCoords()));str.advance()}else if(prefixes.hasOwnProperty(current)){tokens.push(makeToken("prefix",prefixes[current],str.getCoords()));str.advance()}else if(current>" "&&current<="~"){tokens.push(identifier(str))}else{const tmp=whitespace(str);if(ws){tokens.push(tmp)}}}return tokens}}espace.Tokenizer=Tokenizer})();
})(typeof module !== "undefined" && module.exports ? module.exports : window.espace = {})